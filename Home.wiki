== pyaes ==

=== What is it? ===

**pyaes** is
* **an implementation of AES** (Advanced Encryption Standard) cipher in pure Python, including 128/192/256 bits with ECB & CBC modes
* **easy to use:** it has a simple [[http://www.python.org/dev/peps/pep-0272/|PEP 272 cipher API]].
* **not too slow:** it's as fast as Python permits without obfuscating the code
* **well-tested:** it includes a test runner to check the operation against NIST published test vectors
* **raw cipher only:** it does not do padding/verification/key derivation -- any secure crypto protocol should. If that's what you want, [[http://www.keyczar.org/|Keyczar]] is more useful

=== How? ===

{{{
#!python
>>> import pyaes
>>> cryptor = pyaes.new('secret_secretkey', pyaes.MODE_CBC, IV='_some_random_iv_')
>>> ciphertext = cryptor.encrypt('This is a test! What could possibly go wrong?___')
>>> ciphertext
'S8\n\x81\xee3\x86\xd6\t\xf8\xc6\xde~\xdc\x14H#\xd2\xe1\xda\xd79\x81\xb7>\xdd\xed\xaa\xed\xcfp\xee\xc6\x8f(\xdc\xb1A"\xe9[\x9f{\x8e\xa6F\xfbQ'
>>> decryptor = pyaes.new('secret_secretkey', pyaes.MODE_CBC, IV='_some_random_iv_')
>>> decryptor.decrypt(ciphertext)
'This is a test! What could possibly go wrong?___'
}}}

=== Why? ===

The main motivation for writing this was to provide the [[http://pypy.org/|PyPy project]] with a crypto benchmark for [[http://speed.pypy.org/|speed.pypy.org]]. As of September 2010 this benchmark is part of the PyPy benchmarks repository, but not yet visible on the website.

I was looking at the [[https://code.google.com/p/slowaes/|SlowAES project]] first; it was very slow, so I created [[https://bitbucket.org/intgr/slowaes-optimized|an optimization branch]] of it. However, I wasn't happy with the way the code was written -- its legacy as C code converted to JavaScript, then converted to Python, was showing. The API was also weird by Python standards.

So pyaes was born! Written from scratch to be Pythonic and benchmark-quality.

=== Speed ===

Even though pyaes is an optimized Python implementation, Python itself is still slow. It should be capable of around **80 kB/s** on modern hardware; that's **1000x slower** than pure C implementations.

If you have any ideas how to make it faster, I'm interested in hearing your thoughts. :)
